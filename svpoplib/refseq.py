"""
Generate annotations.
"""

import pandas as pd
import numpy as np


class RefgeneToken:
    """
    Represents one region of a refgene record.

    Fields:
    * name: Region annotation (INTRON, CDS, UTR5, UTR3, NCRNA, END)
    * start: Start position of the region (1-based, inclusive)
    """

    def __init__(self, name, start):
        """
        Create record.

        :param name: Region name.
        :param start: Start position (1-based, inclusive).
        """
        self.name = name
        self.start = start

    def __int__(self):
        return self.start

    def __str__(self):
        return self.name

    def __repr__(self):
        return 'RefgeneToken[name={}, start={}]'.format(self.name, self.start)

    def __gt__(self, other):
        self.start > int(other)

    def __lt__(self, other):
        self.start < int(other)

    def __ge__(self, other):
        self.start >= int(other)

    def __le__(self, other):
        self.start <= int(other)

    def __eq__(self, other):
        self.start == int(other)

    def __ne__(self, other):
        self.start != int(other)


def tokenize_refgene_annotation(bed_row):
    """
    Get a list of refGene annotations for a region.

    :param bed_row: Pandas Series of one record with refGene fields (UCSC refGene).

    :return: A list of annotations, one for each region (UTR5, CDS, etc). The last record is
        "END" with the first base after the transcribed region.
    """

    token_list = list()

    # Set token for strand
    if bed_row['strand'] == '+':
        is_fwd = True
    elif bed_row['strand'] == '-':
        is_fwd = False
    else:
        raise RuntimeError('Bad strand (not + or -) on row {}: {}'.format(bed_row.name, bed_row['strand']))

    # States:
    # * INTRON
    # * CDS (CDS in exon)
    # * UTR5 (5' UTR in exon)
    # * UTR3 (3' UTR in exon)
    # * NCRNA (Exonic region in a non-coding gene, but not in CDS or UTR)

    # Header line (from bedtools intersect with -wa -wb)
    # "#CHROM POS END ID #chrom txStart txEnd name comName cdsStart cdsEnd exonStarts exonEnds"

    # Get exon locations
    exon_starts = str(bed_row['exonStarts'])

    if exon_starts.endswith(','):
        exon_starts = exon_starts[0:-1]

    exon_ends = bed_row['exonEnds']

    if exon_ends.endswith(','):
        exon_ends = exon_ends[0:-1]

    exons = [(int(a) + 1, int(b)) for a, b in zip(exon_starts.split(','), exon_ends.split(','))]
        # Note: An exon is defined for all genes (including RNA genes), so this list is never empty

    # Save other attributes
    cds_start = int(bed_row['cdsStart']) + 1
    cds_end = int(bed_row['cdsEnd'])
    tx_start = int(bed_row['txStart']) + 1
    tx_end = int(bed_row['txEnd'])

    exons.append((tx_end, tx_end))  # Sentinel at end (to avoid bounds checking)

    # Get the annotation for exonic CDS (CDS if coding, NCRNA if non-coding)
    if cds_end - cds_start > 0:
        exon_cds = 'CDS'

    else:  # for ncRNA, cds_start == cds_end
        exon_cds = 'NCRNA'
        cds_start = tx_start  # cds_end is tx_end, so call the whole gene region CDS

    # Set initial state
    position = tx_start

    next_exon_start, next_exon_end = exons.pop(0)

    in_exon = not (position < next_exon_start)

    # Get remaining tokens
    while position < tx_end:

        if in_exon:

            if position < cds_start:
                token_list.append(RefgeneToken('UTR5' if is_fwd else 'UTR3', position))
                position = min((cds_start, next_exon_end))

            elif position < cds_end:
                token_list.append(RefgeneToken(exon_cds, position))
                position = min((next_exon_end, cds_end))

            else:
                token_list.append(RefgeneToken('UTR3' if is_fwd else 'UTR5', position))
                position = next_exon_end

            if position == next_exon_end:
                in_exon = False
                next_exon_start, next_exon_end = exons.pop(0)
                position += 1

        else:
            token_list.append(RefgeneToken('INTRON', position))
            position = next_exon_start
            in_exon = True

    # Cap end and return list
    token_list.append(RefgeneToken('END', position))

    return token_list


def get_refgene_counts(bed_row):
    """
    Get the number of bases an SV affects by gene annotation (INTRON, CDS, UTR, etc).

    :param bed_row: Row from a merged BED file (generated by rule `variant_anno_merge_refseq_with_gene_bed`).

    :return: A Pandas Series with the counts for the number of bases by "INTRON", "UTR5", "CDS", "UTR3",
        "NCRNA", and "INTERGEN".
    """

    # Init
    count_array = pd.Series(
        {
            'INTRON': 0,
            'UTR5': 0,
            'CDS': 0,
            'UTR3': 0,
            'NCRNA': 0,
            'INTERGEN': 0
        },
        dtype=int
    )

    # Get refgene regions
    token_list = tokenize_refgene_annotation(bed_row)

    position = int(bed_row['POS']) + 1      # 0-based to one-based
    end_position = int(bed_row['END']) + 1  # 0-based to one-based, preserved exclusive end

    if bed_row['SVTYPE'] == 'INS':  # Insertions have 0 length, give them a coordinate of one base
        end_position += 1

    # Get first token
    token = token_list.pop(0)
    state = 'INTERGEN'  # Start in an intergenic region

    if token.name == 'END':
        position = end_position

    while position < end_position:

        if position < token.start:
            next_position = min((token.start, end_position))

            if bed_row['SVTYPE'] == 'INS':
                count_array[state] = int(bed_row['SVLEN'])
                break

            count_array[state] += next_position - position
            position = next_position

        if token_list:
            state = token.name
            token = token_list.pop(0)

        else:
            if end_position > token.start:
                count_array['INTERGEN'] += end_position - token.start
            break

    # Return Series
    return count_array


def get_refgene_counts_df(df_sv_refseq):
    """
    Get a dataframe of variants and a summary of gene regions affected by the variant.

    Returns a dataframe with fields (in order):
    * ID
    * ACCESSION
    * GENE
    * INTRON
    * UTR5
    * CDS
    * UTR3
    * NCRNA
    * INTERGEN

    :param df_sv_refseq: Variants merged with RefSeq records.

    :return: Dataframe of affected bases by refseq record.
    """

    # Return an empty frame for no records
    if df_sv_refseq.shape[0] == 0:
        return pd.DataFrame([], columns=['ID', 'ACCESSION', 'GENE', 'INTRON', 'UTR5', 'CDS', 'UTR3', 'NCRNA', 'INTERGEN'])

    # Get counts
    df_sv_refseq = df_sv_refseq.copy()
    df_sv_refseq.set_index(['ID', 'name', 'comName'], inplace=True)
    df_sv_refseq.index.rename(('ID', 'ACCESSION', 'GENE'), inplace=True)

    df = df_sv_refseq.apply(get_refgene_counts, axis=1)

    return df.reset_index()
