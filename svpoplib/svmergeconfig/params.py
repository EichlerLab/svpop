"""
Merge configuration objects populated after lexing and parsing the parameter
specification string. The resulting objects convert the AST (abstract syntax
tree) generated by the parser to a set of configured objects that can be easily
used by the merging code to execute the merge steps.

Definitions:
* Parameter (param): Specifies the type and name of configurable attributes.
* Argument (arg): Actual value of a parameter.
* Specification: A merge type (exact, ro, szro) and all arguments for that type.

Each specification type (exact, ro, szro) has a set number of parameters it
recognizes, which are specified as a list of ParamSpec objects. Each ParamSpec
gives the type, name, default value, min/max bounds (optional), if "unlimited"
is allowed, and the value set for unlimited. The order of this list sets the
order of positional parameters (unnamed, e.g. "200") and the names of
specifications gives the keys for named parameters (e.g. "distance=200").

A MergeSpec object is a fully configured object with the specification type
identifier (spec_type) and all parameters set as attributes to the object
(every name from a specification list is set). Any arguments not specified are
set to default values according to the parameter specification list. The
base MergeSpec class carries out most of the operations to check and set
arguments according to the parameter list (i.e. errors are generated here, such
as incorrect argument types and unrecognized parameters). Each specification
type is a subclass of MergeSpec and has a hard-coded parameter list. Constructing
a MergeSpec object is done by determining the correct MergeSpec subclass based
on the parameter type from the AST and instantiating it with the argument list
from the AST.
"""

import svpoplib.aligner
from . import parser


# Recognized values for the val_type field of specification objects and a set of
# types they may match. For example, "num" type can accept a float or int value,
# but not unlimited. In many cases, float is assumed, but an int is allowed to
# to convert to a float so specifications don't have to require float-like input
# (e.g. "2" is converted to "2.0").
TYPE_MATCHER = {
    'num': {'float', 'int'},
    'num_u': {'float', 'int', 'unlimited'},
    'int_u': {'int', 'unlimited'},
    'float_u': {'float', 'unlimited'},
    'int': {'int'},
    'float': {'float'}
}

# Define a list of reserved parameter names for each specification (ro, szro,
# etc). These are fields used by the paramter object and no parameter arguments
# are allowed to have the same names.
RESERVED_PARAM_NAMES = {
    'spec_type',         # Name of the specification type ("exact", "ro", "szro", etc.)
    'allow_matcher',     # Specification allows sequence a matcher
    'arg_list',          # List of arguments
    'matcher',           # Matcher parameters if a matcher was defined for this specification (not set for a global matcher)
    'param_spec_list',   # List of parameter specifications for this specification type
    'match_seq',         # Set to True if a match is performed. Implies aligner is not None, read_seq is true, and all match paramters are set
    'aligner',           # Aligner object for "match"
    'align_match_prop',  # Proportion of the maximum value to allow or None variant sequence comparisons should not be done
    'align_param',       # Alignment paramters used to initialize the aligner
    'read_seq',          # Set to true if a sequence is required (i.e. match, but could be used independent of match in the future)
    'matcher_global'     # Set to true if the configured matcher is global, not local to the parameter object
}

#
# Global defaults
#

# Default score for the matcher. Stored here as a globally accessible default.
DEFAULT_MATCHER_SCORE = 0.8


#
# Config function
#

def get_merge_config(merge_params):
    """
    Get a configured parameter set.

    :param merge_params: Merge parameter string.

    :return: Merge configuration object.
    """
    merge_parser = parser.MergeParser()

    try:
        parser_ast = merge_parser.parse(merge_params)
    except RuntimeError as e:
        raise RuntimeError(f'Error parsing merge parameters "{merge_params}": {e}')

    return MergeConfig(parser_ast)


#
# MergeConfig
#

class MergeConfig(object):
    """
    A fully configured merger. Takes the AST output from the parser and generates a configuration object.
    """

    def __init__(self, parser_ast):

        # Check arguments
        if parser_ast is None:
            raise RuntimeError('MergeConfig: Cannot create a merge config object: parser_ast is None')

        self.parser_ast = parser_ast

        missing_keys = [val for val in ('strategy', 'spec_list') if val not in parser_ast.keys()]

        if missing_keys:
            raise RuntimeError('MergeConfig: Missing {} AST key(s): {}'.format(
                len(missing_keys),
                ', '.join(missing_keys)
            ))

        # Create an empty MergeConfig
        self.strategy = parser_ast['strategy'].lower()

        self.spec_list = list()
        self.default_matcher = None

        # Set REF/ALT flag (check REF and ALT for SNVs) based on the strategy name
        self.refalt = self.strategy in {'nrsnv', 'nrsnp'}

        # Add specifications
        for index in range(len(parser_ast['spec_list'])):
            spec_ast = parser_ast['spec_list'][index]

            # Check keys
            missing_keys = [val for val in ('type', 'val_list') if val not in spec_ast.keys()]

            if missing_keys:
                raise RuntimeError('MergeConfig: Missing {} specification AST key(s) for specification at position {}: {}'.format(
                    len(missing_keys),
                    index + 1,
                    ', '.join(missing_keys)
                ))

            # Process specification type
            spec = None

            if self.strategy == 'nr':
                if spec_ast['type'] == 'exact':
                    spec = MergeSpecExact(spec_ast['val_list'])
                elif spec_ast['type'] == 'ro':
                    spec = MergeSpecRo(spec_ast['val_list'])
                elif spec_ast['type'] == 'szro':
                    spec = MergeSpecSzro(spec_ast['val_list'])
                elif spec_ast['type'] == 'distance':
                    spec = MergeSpecDistance(spec_ast['val_list'])
                elif spec_ast['type'] == 'match':
                    self.default_matcher = MergeSpecMatch(spec_ast['val_list'])
                else:
                    raise RuntimeError(f'MergeConfig {self.strategy}: Merge specification type at {index + 1} is unknown: {spec_ast["type"]}')

            elif self.strategy in {'nrsnv', 'nrsnp'}:
                if spec_ast['type'] == 'exact':
                    spec = MergeSpecExact(spec_ast['val_list'])
                elif spec_ast['type'] == 'distance':
                    raise RuntimeError('MergeSpecDistance is not yet implemented')
                    spec = MergeSpecDistance(spec_ast['val_list'])
                else:
                    raise RuntimeError(f'MergeConfig {self.strategy}: Merge specification type at {index + 1} is unknown: {spec_ast["type"]}')

            else:
                raise RuntimeError(f'MergeConfig: Unrecognized strategy {self.strategy}')

            if spec is not None:
                self.spec_list.append(spec)

        # Set REF/ALT status for SNVs
        if self.refalt:

            # No matcher allowed for REF/ALT (REF/ALT does the checking)
            if self.default_matcher is not None:
                raise RuntimeError(f'Default matcher is not supported for strategy {self.strategy}: REF and ALT are checked by SNV strategies')

            for i in range(len(self.spec_list)):
                spec = self.spec_list[i]

                # Error if a matcher was defined
                if spec.matcher is not None:
                    raise RuntimeError(f'Matcher is not supported for merge specification {spec.spec_type}: REF and ALT are checked by SNV strategies')

                # Assign refalt
                spec.refalt = True

        # Add default matcher
        if self.default_matcher is not None:
            for spec in self.spec_list:
                if spec.matcher is None:
                    spec.set_matcher(self.default_matcher, matcher_global=True)

        # Set fields
        self.read_seq = any([spec.read_seq for spec in self.spec_list])

        return

    def any_match(self):
        """
        Return True if any merge spec has a matcher.

        :return: True if any merge spec has a matcher.
        """
        return any([merge_spec.match_seq for merge_spec in self.spec_list])

    def __repr__(self, pretty=False):

        repr_str = 'MergeConfig(' + self.strategy

        # Strings for each specification
        spec_str = [
            spec.__repr__(show_matcher=(not spec.matcher_global)) for spec in self.spec_list
        ]

        # Double colon separates strategy from specifications
        if len(spec_str) > 0:
            if pretty:
                repr_str += '\n'
            else:
                repr_str += '::'

        # Add specifications
        if pretty:
            repr_str += ''.join(['    {}\n'.format(val) for val in spec_str])
        else:
            repr_str += ':'.join(spec_str)

        # Add global default matcher
        if self.default_matcher is not None:
            if pretty:
                repr_str += '\n' if len(spec_str) == 0 else ''
                repr_str += '    ' + self.default_matcher.__repr__() + '\n'
            else:
                if len(spec_str) > 0:
                    repr_str += ':'

                repr_str += self.default_matcher.__repr__()

        repr_str += ')'

        return repr_str


#
# ParamSpec
#

class ParamSpec(object):
    """
    Specifies a parameter, default values, and legal ranges.
    """

    def __init__(
        self,
        val_type, default, name,
        min_val=None, min_inclusive=True,
        max_val=None, max_inclusive=True,
        unlimited_val=None
    ):
        self.val_type = val_type
        self.default = default
        self.name = name
        self.min_val = min_val
        self.min_inclusive = min_inclusive
        self.max_val = max_val
        self.max_inclusive = max_inclusive
        self.unlimited_val = unlimited_val

        if self.val_type is None:
            raise RuntimeError('ParamSpec.__init__(): val_type may not be None')

        if self.name is None:
            raise RuntimeError('ParamSpec.__init__(): name may not be None')

    def check(self, param_tuple):
        """
        Check a parameter tuple of (type, value, name).

        Type should match a key in TYPE_MATCHER. No values may be None.
        """

        if param_tuple is None:
            raise RuntimeError('Cannot check paramters: None')

        if len(param_tuple) != 3:
            raise RuntimeError(f'Expected 3 parameters in param_tuple: Found {len(param_tuple)}')

        # Check type
        if param_tuple[0] not in TYPE_MATCHER[self.val_type]:
            if param_tuple[0] not in TYPE_MATCHER.keys():
                raise RuntimeError(f'BUG: Unrecognized type for parameter "{param_tuple[2]} = {param_tuple[1]}": {param_tuple[0]}')
            else:
                allowed_types = ', '.join(sorted(TYPE_MATCHER[self.val_type]))
                raise RuntimeError(f'Illegal type for "{param_tuple[2]} = {param_tuple[1]}": {param_tuple[0]}: expected {allowed_types}')

        # Check name and value
        if param_tuple[0] != 'unlimited':
            if param_tuple[1] is None:
                raise RuntimeError(f'Illegal value for "{param_tuple[2]} = {param_tuple[1]}": None')

            # Check bounds
            if self.min_val is not None:
                if param_tuple[1] < self.min_val or (param_tuple[1] == self.min_val and not self.min_inclusive):
                    raise RuntimeError(f'Illegal range for "{param_tuple[2]} = {param_tuple[1]}": Minimum allowed value is {self.min_val} ({"inclusive" if self.min_inclusive else "exclusive"})')

            if self.max_val is not None:
                if param_tuple[1] > self.max_val or (param_tuple[1] == self.max_val and not self.max_inclusive):
                    raise RuntimeError(f'Illegal range for "{param_tuple[2]} = {param_tuple[1]}": Maximum allowed value is {self.max_val} ({"inclusive" if self.max_inclusive else "exclusive"})')

            return param_tuple[1]
        else:
            return self.unlimited_val


#
# Param set base class
#

class MergeSpec(object):
    """
    A set of positional and/or named parameters.
    """

    def __init__(self, spec_type, arg_list, param_spec_list, allow_matcher=True):

        # Check param spec and make a dictionary of indices, and set default values
        if param_spec_list is None:
            param_spec_list = list()

        param_spec_index = dict()

        for index in range(len(param_spec_list)):
            param_spec = param_spec_list[index]

            if param_spec.name in RESERVED_PARAM_NAMES:
                raise RuntimeError(f'BUG: Reserved parameter name cannot be part of a parameter spec: {param_spec.name}')

            param_spec_index[param_spec.name] = index

            if param_spec.name in self.__dict__.keys():
                raise RuntimeError(f'Specification type {spec_type}: Param spec name clashed with a name already defined in the parameter set: {param_spec.name}')

            self.__dict__[param_spec.name] = param_spec.default

        # Specification fields
        self.spec_type = spec_type          # Spec type name
        self.allow_matcher = allow_matcher  # Matcher is allowed for this specification type
        self.arg_list = arg_list            # List of arguments used to configure this parameter set
        self.param_spec_list = param_spec_list

        # Sequence match parameters
        self.matcher = None           # Object used to configure the matcher if one was set
        self.match_seq = False        # If True, match sequences by aligning and applying a match threshold
        self.aligner = None           # Configured alignger with match/mismatch/gap parameters set
        self.align_match_prop = None  # Match proprotion threshold (matching bases / sequence length)
        self.align_param = None       # Alignment parameters used to configure aligner
        self.matcher_global = False   # Set to true if the configured matcher is the global default. This is a clue used by __repr__() on the MergeConfig

        # REF/ALT
        self.refalt = False  # Set to true for SNVs, REF and ALT must match

        # Read sequence
        self.read_seq = False  # If set, a parameter requires sequence-resolution as a SEQ column (flag to load SEQ from FASTA)

        # Check and set parameters
        named_state = False    # Set to True when a named parameters is found. Only named parameters are allowed after
        matcher_state = False  # Set to True when a matcher is found. Nothing is allowed after.

        # Iterate parameters
        for index in range(len(arg_list)):

            param_tuple = arg_list[index]

            if param_tuple is None:
                continue

            # Check formatting
            if param_tuple is None:
                raise RuntimeError(f'Specification type {spec_type}: Cannot check paramters: None')

            if len(param_tuple) != 3:
                raise RuntimeError(f'Specification type {spec_type}: Expected 3 parameters in param_tuple: Found {len(param_tuple)}')

            # Check for matcher
            if matcher_state:
                raise RuntimeError(f'Specification type {spec_type}: Parameter at position {index + 1} follows a matcher (matcher must be the last item in a parameter list)')

            if param_tuple[0] == 'match':
                if not allow_matcher:
                    raise RuntimeError(f'Specification type {spec_type}: Found matcher at position {index + 1}: No matcher is allowed for this specification type')

                self.set_matcher(MergeSpecMatch(param_tuple[1]))

                matcher_state = True

                continue

            # Check states
            if named_state and param_tuple[2] is None:
                raise RuntimeError(f'Specification type {spec_type}: Unnamed value {param_tuple[0]} at position {index + 1} follows a named value: Positional parameters must come before named parameters')

            # Get spec
            if param_tuple[2] is None:
                param_index = index

                if param_index >= len(param_spec_list):
                    raise RuntimeError(f'Specification type {spec_type}: Positional parameter {index + 1} is out of range: Max {len(param_spec_list)}')

            else:
                param_index = param_spec_index.get(param_tuple[2], None)

                if param_index is None:
                    raise RuntimeError(f'Specification type {spec_type}: Unknown named parameter: {param_tuple[2]}')

                if param_index >= len(param_spec_list):
                    raise RuntimeError(f'BUG: Specification type {spec_type}: Named parameter at position {index + 1} ({param_tuple[2]}) returns a parameter specification index that is out of range: {param_index}: Max {len(param_spec_list)}')

                named_state = True

            param_spec = param_spec_list[param_index]

            # Check and set
            try:
                self.__dict__[param_spec.name] = param_spec.check(param_tuple)

            except RuntimeError as e:
                raise RuntimeError(f'Specification type {spec_type}: {e}')

    def set_matcher(self, param_set_matcher=None, matcher_global=False):
        """
        Set the matcher on this object.

        :param param_set_matcher: Matcher parameter set.
        :param matcher_global: Set if the configured matcher was global (not specific to this rule).
        """

        # Reset to no matcher if None.
        if param_set_matcher is None:

            # Sequence match parameters
            self.matcher = None
            self.match_seq = False
            self.aligner = None
            self.align_match_prop = None
            self.align_param = None
            self.matcher_global = False

            # Read sequence
            self.read_seq = False

            return

        # Check matcher types
        if self.spec_type == 'matcher':
            raise RuntimeError('BUG: Attempted to call set_matcher() on a matcher parameter set: set_matcher() should be called on non-matcher parameters with a matcher parameter set as its argument')

        if param_set_matcher.spec_type != 'match':
            raise RuntimeError(f'Attempted to call set_matcher() with a non-matcher parameter set argument: {param_set_matcher.spec_type}')

        # Check if matcher is allowed
        if not self.allow_matcher:
            raise RuntimeError(f'Specification type {spec_type}: Matcher is not allowed for this specification type')

        # Create aligner and set matcher fields
        self.aligner = svpoplib.aligner.ScoreAligner(
            match=param_set_matcher.match,
            mismatch=param_set_matcher.mismatch,
            gap_open=param_set_matcher.open,
            gap_extend=param_set_matcher.extend,
            map_limit=param_set_matcher.limit,
            jaccard_kmer=param_set_matcher.ksize
        )

        self.align_match_prop = param_set_matcher.score
        self.align_param = param_set_matcher

        self.match_seq = True
        self.read_seq = True

        self.matcher = param_set_matcher
        self.matcher_global = matcher_global

        return

    def __repr__(self, show_matcher=True):
        repr_str = f'MergeSpec({self.spec_type}:'

        arg_str = ','.join([
            '{}={}'.format(
                param_spec.name,
                self.__dict__[param_spec.name]
            ) for param_spec in self.param_spec_list
        ])

        if self.matcher is not None and show_matcher:
            if arg_str:
                arg_str += ','

            arg_str += self.matcher.__repr__()

        repr_str += arg_str + ')'

        return repr_str


#
# Param set concrete classes
#

class MergeSpecSzro(MergeSpec):
    """
    Param set: Size-reciprocal-overlap.

    Perform reciprocal overlap (OR) on sizes only, not position (i.e. RO if variants were shifted to the same start
    position).

    Matches have a mandatory distance constraint
    """

    def __init__(self, arg_list):
        super().__init__(
            'szro',
            arg_list,
            [
                ParamSpec('num', 0.5, 'szro', 0.0, False, 1.0, True),
                ParamSpec('int_u', 200, 'dist', 0, True),
                ParamSpec('num_u', None, 'szdist', 0.0, True)
            ],
            True
        )

        if self.dist is None and self.szdist is None:
            raise RuntimeError(f'Specification type {spec_type}: At least one of "dist" or "szdist" arguments must not be unlimited')

        return


class MergeSpecDistance(MergeSpec):
    """
    Param set: Distance merge.

    Merge by distance. May be restricted by size RO and offset size. Like szro, but szro parameter may be unset.
    """

    def __init__(self, arg_list):
        super().__init__(
            'distance',
            arg_list,
            [
                ParamSpec('num', None, 'szro', 0.0, False, 1.0, True),
                ParamSpec('int', 500, 'dist', 0, True),
                ParamSpec('num_u', None, 'szdist', 0.0, True)
            ],
            True
        )

        if self.dist is None and self.szdist is None:
            raise RuntimeError(f'Specification type {spec_type}: At least one of "dist" or "szdist" arguments must not be unlimited')

        return

class MergeSpecRo(MergeSpec):
    """
    Param set: Reciprocal overlap (RO).

    Classic RO definition. For insertions, the END position is POS + SVLEN for RO computation (does not affect
    merged calls, END is still POS + 1  for INS after intersects).
    """

    def __init__(self, arg_list):
        super().__init__(
            'ro',
            arg_list,
            [
                ParamSpec('num', 0.5, 'ro', 0.0, False, 1.0, True),
                ParamSpec('int_u', None, 'dist', 0, True)
            ],
            True
        )

        return


class MergeSpecExact(MergeSpec):
    """
    Parameter set: Exact intersects.
    """

    def __init__(self, arg_list):
        super().__init__('exact', arg_list, [], True)

        return


class MergeSpecMatch(MergeSpec):
    """
    Parameter set: Matcher specification objects.
    """

    def __init__(self, arg_list):
        super().__init__(
            'match',
            arg_list,
            [
                ParamSpec('num', DEFAULT_MATCHER_SCORE, 'score', 0.0, False, 1.0, True),
                ParamSpec('num', 2.0, 'match', 0.0, False),
                ParamSpec('num', -1.0, 'mismatch', None, None, 0.0, False),
                ParamSpec('num', -1.0, 'open', None, None, 0.0, True),
                ParamSpec('num', -0.25, 'extend', None, None, 0.0, True),
                ParamSpec('int_u', 4000, 'limit', 0, True),
                ParamSpec('int', 9, 'ksize', 1, True),
            ],
            False
        )

        return
