svpoplib/rules.py
Functions designed to directly support rules, such as input functions for Snakemake rules.
            sample_table['VERSION'] = np.nan
            sample_table['PARAMS'] = np.nan
        sample_table.set_index(['NAME', 'SAMPLE'], inplace=True, drop=False)
    :param caller_type: Entry must be declared as this type (points to parser used to process the input data).
        raise RuntimeError('Cannot get input for entry name: None')
def get_bed_fa_input(sample_entry, wildcards, default=None):
    Locate FASTA sequence input file.
    :return: FASTA input file location
    :param caller_type: Entry must be declared as this type (points to parser used to process the input data).
svpoplib/vcf.py
    :return: A series keyed by IDs for sequences. SNVs and INVs are given np.nan sequence.
                df_seq_list.append(pd.Series(np.nan, index=list(id_set)))
svpoplib/seq.py
            input_format.upper(),
def fa_to_record_iter(fa_file_name, record_set=None, require_all=True, input_format='fasta'):
    :param input_format: Input file format. Must be "fasta" or "fastq" (case sensitive).
    if input_format not in {'fasta', 'fastq'}:
        raise RuntimeError(f'Unrecognized input format: "{input_format}"')
        for record in SeqIO.parse(in_file, input_format):
                    input_format.upper(),
            input_format.upper(),
svpoplib/varbed.py
svpoplib/svset.py
import numpy as np
            min = np.int32(self.args['min'])
            max = np.int32(self.args['max'])
            min = np.int32(tok[0])
            max = np.int32(tok[1])
    # Check input
def get_filter_input_files(filter_spec_str, wildcards, config):
    Get a list of input files. Useful for Snakemake rules.
    :return: A list of input files.
svpoplib/sm.py
    Set a value on a named list in Snakemake. This includes objects for wildcards, input, output, parameters, and log.
    :param named_list: Named list (wildcards, input, output, parameters, etc).
    :param value: Value to set. May be a string or an input function taking a single argument, `wildcards`.
        # Input function
            raise RuntimeError('Cannot execute input function with wildcards = None')
svpoplib/svlenoverlap.py
import numpy as np
    df_source['SVLEN'] = np.abs(df_source['SVLEN'])
    df_target['SVLEN'] = np.abs(df_target['SVLEN'])
        '#CHROM': np.object,
        'POS': np.int32,
        'END': np.int32,
        'SVLEN': np.int32,
        'ID': np.object
    df_source.set_index('ID', inplace=True)
    df_target.set_index('ID', inplace=True)
            ro_min = np.float16(ro_min)
        if ro_min <= np.float16(0.0) or ro_min > np.float16(1.0):
            szro_min = np.float16(szro_min)
        if szro_min <= np.float16(0.0) or szro_min > np.float16(1.0):
            offset_max = np.int32(offset_max)
            offsz_max = np.float16(offsz_max)
        if offsz_max < np.float16(0.0):
            lambda row: np.min([svlen / row['SVLEN'], row['SVLEN'] / svlen]),
            lambda row: np.min(
                    np.abs(pos - row['POS']),
                    np.abs(end - row['END'])
            df_target_row_pool['MATCH'] = np.nan
        df_target_chr.drop(max_row['TARGET_ID'], inplace=True)
svpoplib/gt.py
import numpy as np
        return np.nan
    if all(((1 - val) < np.float64(0.0000001) for val in list_freqs)):
        return np.float64(0.0)
    list_popsizes = [np.float64(x) for x in list_popsizes]
    list_freqs = [np.float64(x) for x in list_freqs]
    locus_fst = np.float64(locus_fst)
        return np.float64(0.0)
    Input BED files must have a 'SVLEN' field.
                      index=('HOM-REF', 'HOM-ALT', 'HET', 'NO-CALL'), dtype=np.int
    df['INS_MED'] = group.median()['SVLEN'].astype(np.int)
    df['DEL_MED'] = group.median()['SVLEN'].astype(np.int)
    df['ALL_MED'] = group.median()['SVLEN'].astype(np.int)
svpoplib/aligner.py
import numpy as np
    return np.sum(
        [np.min([count1[key], count2[key]]) for key in key_set]  # Matching k-mers
    ) / np.sum(
        [np.max([count1[key], count2[key]]) for key in key_set]  # All k-mers
        max_len = np.max([len(seq_a), len(seq_b)])
        min_len = np.min([len(seq_a), len(seq_b)])
                        np.min([self.score_align(seq_a, seq_b + seq_b), min_len * self.__match]) / (max_len * self.__match),
svpoplib/anno/__init__.py
svpoplib/anno/align.py
import numpy as np
svpoplib/__init__.py
svpoplib/plot/upset.py
import numpy as np
            ).astype(np.int32).values
        #     ].fillna(0).astype(np.int32).values
    bar_labels = np.array(set_counts.index)
    bubble_x = np.asarray(
    bubble_y = np.asarray(
    bubble_col = np.asarray(
    bar_bottom = np.zeros(bar_labels.shape[0]).astype(np.int32)  # Bottom of next stacked bar
    count_shift = 0.02 * np.max(set_counts.values)
    ax2.set_yticks(np.arange(len(df_caller_label)))
    ax2.set_yticklabels(np.array(df_caller_label))
svpoplib/plot/__init__.py
svpoplib/plot/venn.py
import numpy as np
                    int(np.round(np.mean(set_lengths))),
                    int(np.round(np.median(set_lengths))),
                    int(np.ceil(np.mean(set_lengths))),
                    int(np.ceil(np.median(set_lengths))),
svpoplib/plot/ideo.py
import numpy as np
        sd_min = np.min(df_sd['MATCH'])
    matrix_chr_name = np.array(
    matrix_chr_len = np.array(
    max_pair_bp = np.max(
        np.apply_along_axis(np.sum, 1, matrix_chr_len)
                    bins=np.int32(matrix_chr_len[i, j] // 1e6),
                np.min([y_min, -anno_height]),
                np.max([y_max, anno_height])
svpoplib/constants.py
svpoplib/svmergeconfig/params.py
# to convert to a float so specifications don't have to require float-like input
        self.refalt = self.strategy in {'nrsnv', 'nrsnp'}
            elif self.strategy in {'nrsnv', 'nrsnp'}:
svpoplib/svmergeconfig/__init__.py
svpoplib/svmergeconfig/parser.py
                        if len(p.lexer.lexdata) - p.lexpos > 5 else 'at end of input'
svpoplib/svmergeconfig/lexer.py
            'Illegal character in input: "{}" at position {} ({})"'.format(
svpoplib/util.py
svpoplib/ref.py
import numpy as np
    :param missing: Return `np.nan` for values with no mapping if `True`.
        lambda val: grc_table[val] if val in key_set else np.nan
    Determine if each chromosome name is a proper chromosome (primary assembly, not unplaced or unlocalized).
        df.set_index(index_col, inplace=True)
    df.set_index('CHROM', inplace=True)
    if np.any(df['LEN'] != df_fai['LEN']):
svpoplib/refseq.py
import numpy as np
        dtype=np.int
    df_sv_refseq.set_index(['ID', 'name', 'comName'], inplace=True)
    df_sv_refseq.index.rename(('ID', 'ACCESSION', 'GENE'), inplace=True)
svpoplib/callerset.py
            'Attach the name for each input element as a third element on each tuple in the "callsets" list'
def get_caller_set_input(callerset, file_pattern, config, wildcards=None, as_tuple=False):
    Get input for a caller set.
    :return: A list of input files with one file per samples.
    # Make list of input files
def merge_annotations(df_merge, callerset_input, callerset_entry, sort_columns=['#CHROM', 'POS', 'END', 'ID']):
    :param callerset_input: List of input tab or BED files.
    if len(callerset_input) != callerset_entry['n']:
            'Input entry length ({}) does not match caller set definition length ({})'.format(
                len(callerset_input), callerset_entry['n']
        anno_file = callerset_input[index]
        df_anno.set_index('ID', inplace=True, drop=False)
    df_anno.reset_index(inplace=True, drop=True)
        df_anno.sort_values(list(sort_columns), inplace=True)
def fa_iter(df, callerset_entry, callerset_input):
    :param callerset_input: List of input FASTA file in the same order as `callerset_entry['name_list']`
            callerset_input[index], id_dict, require_all=not fa_incomplete
    Determine if merge requires input sequence.
svpoplib/svmerge.py
import numpy as np
        if def_name in {'nr', 'nrsnp', 'nrsnv'}:
    # Check input
        raise RuntimeError('Sample name list length ({}) does not match the input file list length ({})'.format(
    if merge_config.strategy in {'nr', 'nrsnv', 'nrsnp'}:
            df_support.set_index('ID', inplace=True, drop=False)
            df_new.set_index('ID', inplace=True, drop=False)
            df.sort_values(['#CHROM', 'POS', 'END', 'ID'], inplace=True)
        # Choose a MATCH default for self variants (1.0 if any variants were matched by sequence, np.nan otherwise)
            df['SUPPORT_MATCH'] = np.nan
        df['SUPPORT_OFFSET'] = df['SUPPORT_OFFSET'].apply(lambda val: np.max([0, val]))
        df['SUPPORT_RO'] = np.abs(df['SUPPORT_RO'])
        df['SUPPORT_SZRO'] = np.abs(df['SUPPORT_SZRO'])
        df['SUPPORT_OFFSZ'] = np.abs(df['SUPPORT_OFFSZ'])
        df['SUPPORT_MATCH'] = np.abs(df['SUPPORT_MATCH'])
            inplace=True
        df.drop_duplicates(['ID', 'SUPPORT_SAMPLE'], keep='first', inplace=True)
        df.sort_values(['ID', 'SUPPORT_SAMPLE'], inplace=True)
            df_support['SUPPORT_MATCH'] = np.nan
        df_support.reset_index(inplace=True, drop=False)
        raise RuntimeError('Sample name list length ({}) does not match the input file list length ({})'.format(
        # Get samples name and input file name
        df_anno.sort_values(list(sort_columns), inplace=True)
            raise RuntimeError('Empty input for merge set {} after matching full samples set'.format(mergeset))
            raise RuntimeError('Empty input for merge set {}'.format(mergeset))
    :param bed_list: List of input BED files.
        'MERGE_AC': np.int32,
        'MERGE_AF': np.float32
        df_support_sample.set_index('MERGE_SRC_ID', inplace=True, drop=False)
        df_sample.set_index('ID', inplace=True, drop=True)
    df_merge.sort_values(['#CHROM', 'POS', 'END', 'ID'], inplace=True)
            df_merge[col] = np.nan
    df_merge.reset_index(drop=True, inplace=True)
        if np.any(pd.isnull(df['SEQ'])):
        if (np.any(df['SVTYPE'].apply(lambda val: val.upper()) == 'INS')):
    if np.any(df['SVLEN'] < 0):
    df.sort_values(['#CHROM', 'POS', 'END', 'ID'], inplace=True)
    svpoplib.variant.check_unique_ids(df, 'Error reading merge input')
    df.set_index(df['ID'], inplace=True, drop=False)
                n_fail = np.sum([val is None for val in df_support_list])
    max_match = np.nan  # Initialize - set during matches if match_seq, left as np.nan for the support table otherwise
svpoplib/variant.py
import numpy as np
            pos_array = np.array(df_b_sub['POS'])
            end_array = np.array(df_b_sub['END'])
            id_array = np.array(df_b_sub['ID'])
                min_pos_index = np.argmin(np.abs(pos_array - row['POS']))
                min_end_index = np.argmin(np.abs(end_array - row['END']))
                if np.abs(min_pos) < np.abs(min_end):
    Example command-line to generate input table from a VCF:
        seq = row['SEQ'] if 'SEQ' in row else np.nan
        seq = np.nan
        ref = np.nan
        seq = np.nan
        ref = np.nan
        ac = np.nan
    :param tsv_in: Input file name it TSV format. Typically generated by "bcftools query".
    # Process input in chunks
    col_names = None  # Input column names (after first regex transform)
svpoplib/tracks/__init__.py
svpoplib/tracks/variant.py
import numpy as np
    'POS': np.int32,
    'END': np.int32,
    'POS_THICK': np.int32,
    'END_THICK': np.int32,
    'SVLEN': np.int32,
    'DP': np.int32,
    'GQ': np.int32,
    'QA': np.int32,
    'POS': np.int32,
    'SVLEN': np.int32,
    'CALLERSET_N': np.int32,
    'MERGE_AC': np.int32
    df['END'] = df.apply(lambda row: np.min([row['END'], df_fai[row['#CHROM']]]), axis=1)
    df.sort_values(['#CHROM', 'POS', 'ID'], inplace=True)
    df_as.set_index('FIELD', inplace=True, drop=False)
svpoplib/sampleset.py
import numpy as np
def get_sample_set_input(sampleset_name, sampleset_list, file_pattern, config, wildcards=None, as_tuple=False):
    Get input for a caller set.
    :return: A list of input files with one file per samples.
    # Make list of input files
def merge_annotations(df_merge, sampleset_input, sampleset_entry, sort_columns=['#CHROM', 'POS', 'END', 'ID']):
    :param sampleset_input: List of input tab or BED files.
    if len(sampleset_input) != sampleset_entry['n']:
            'Input entry length ({}) does not match sample set definition length ({})'.format(
                len(sampleset_input), sampleset_entry['n']
        anno_file = sampleset_input[index]
        df_anno.set_index('ID', inplace=True, drop=False)
    df_anno.reset_index(inplace=True, drop=True)
            df_anno.sort_values(list(sort_columns), inplace=True)
def fa_write_func(df, wildcards, sampleset_entry, fa_input_pattern, config):
    :param fa_input_pattern: FASTA file input pattern for input into the merge.
    fa_dict = {sample: fa_file for sample, fa_file in svpoplib.sampleset.get_sample_set_input(
        fa_input_pattern,
        if np.sum(df['SAMPLE'] == sample) == 0:
    Determine if merge requires input sequence.
svpoplib/pd.py
import numpy as np
    :param in_file_name: Input file name.
    n_part = np.int32(n_part)
        n_core = np.int32(n_core)
    df_split = np.array_split(df, n_part)
        if np.all(thread_done):
        df.sort_values(sort_list, inplace=True)
